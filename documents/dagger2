依赖注入
1.什么是依赖？(Dependency)
依赖是类于类之间的连接，依赖关系表示一个类依赖于另一个类的定义，通俗来讲就是一种需求
例如：一个人Person 可以买车(Car)和房子(House)，Person类依赖于Car类和House

2.依赖倒置(Dependency inversion principle)  --->六大设计原则之一
依赖倒置是面向对象设计领域的一种软件设计原则
软件设计有6大设计原则，合成SOLID
1). 单一职责
2). 开闭原则
3). 里氏替换原则
4). 依赖倒置原则
5). 接口隔离原则
6). 迪米特法则

依赖倒置：
1.上层模块不应该依赖于底层模块，他们都应该依赖于抽象
2.抽象不应该依赖于细节，细节应该依赖于抽象

3.控制反转(IOC)
控制反转Ioc是Inversion of Control的缩写 ，意思是对于控制权的反转？ 将构造对象的方法教给别人
例如IOC.java类中，
Person把内部创建权利交给了外面的类.Person只关心依赖提供的功能，但并不关心依赖的创建。
这种思想就是IOC,Ioc是一种新的设计模式，它对上层模块与底层模块进行了更进一步的解耦。控制反转的意思是反转了上层模块对于底层模块的依赖控制。

4.依赖注入(Dependency Injection)
为什么要使用依赖注入？
解耦，保证代码的健壮，灵活，提高可维护性，可扩展性。
依赖注入，简称为Di，是一种实现IOC的手段，
因为不因为依赖实现的变动而去修改Person ， 也就是说以可能在Drivable实现类的改变下不改动Person这个了类的代码，
尽可能减少两者之间的耦合。我们需要采用IOC来写代码。
这个需要我们移交出对于实例化的控制权，那么依赖怎么办？Person无法实例化依赖了，它就需要在外部(IOC容器)赋值给他，
这个赋值的动作有个专门的术语叫做注入(injection) ，需要注意的是IOC概念中，这个注入依赖的地方被称为IOC容器，但在依赖注入概念中，一般被称为注射器(injector) 。
表达通俗一点：
我不想自己实例化依赖，你（injector）创建他们，然后在合适的时候注入给我

实现依赖注入有三种方式：
1.构造函数中注入
2.setter方式注入
3.接口注入


Java依赖注入标准
JSR-330 是Java的依赖注入标准。定义了如下的术语描述依赖注入：
1.A类依赖B类型(或者说B被A依赖)，则A类型成为"依赖dependency
2.运行时查找依赖的过程，成为解析resolving 依赖
3.如果找不到依赖的实例，称改依赖是不能满足的unsatisfied
4.在依赖注入机制中，提供依赖的工具成为"依赖注入器 dependency injector 注射器

在标准中，依赖是类型而不是实例/对象、在程序中(运行时)，需要的是依赖的实例 。
javax.inject
包 javax.inject指定了获取对象的一种方法，该方法与构造器，工厂以及服务定位器这些传统方法相比可以获得更好的可重用性，可测试性，
以及可维护性。此方法的处理过程就是大家熟知的依赖注入，它对于大多数应用是非常有价值的。
@Inject
@Qualifier
@Named
@Scope
@Singleton


====> dagger

1.@Inject : @Inject有两个作用，
一是用来标记需要依赖的变量，以此告诉Dagger2为它提供依赖
二是用来标记构造函数，Dagger2通过@Inject注解恶意在需要这个类实例的时候来找这个构造函数，并把相关实例构造出来，以此来为被@Inject标记了的变量提供依赖
只能标注一个构造方法

2.@Module：
3.@Provides
4.@Component
5.@Single


apt技术的应用

依赖提供方： @Module @Provide / @Inject(构造方法)
依赖注入容器： @Component
依赖需求方： @Inject Object


Android Mvp 与 dagger2

1.传统的mvc -->
m： bean数据   v： xml   c：activity
m <----> v 相互耦合 ，activity：c很臃肿

2.mvp  --->
m model 负责数据获取，转化，业务逻辑
v 试图
p m v 解耦

3.MVP中为什么要引入 dagger2？
因为presenter是可以复用的，但是一旦presenter构造方法里面代码有所更改
那么所有引用的地方都得改，这样耦合性就太高了，所以引入了dagger2